러닝타입스크립트 part 1 - ch 2

2.1 타입의 종류 
"타입"은 자바스크립트에서 다루는 값의 형태에 대한 설명입니다.
여기서 '형태'란 값에 존재하는 속성과 메서드 그리고 내장되어 있는 typeof 연산자가 설명하는 것을 의미합니다. 

타입스크립트에서의 원시타입 
- null; // null
- undefined; // undefined
- true; // boolean
- "Louise"; // string
- 1337;  // number
- 1337n; // bigint
- Symbol("Franklin"); // symbol 

2.1.1 타입 시스템
타입 시스템은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합입니다. 

1. 코드를 읽고 존재하는 모든 타입과 값을 이해합니다. 
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인합니다. 
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인합니다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시합니다. 

타입스크립트가 멤버 속성을 함수로 잘못 호출해 타입 오류가 발생하는 코드

```ts
let firstName = "Whitney";
firstName.length();
// error : This expression is not callable.
// Type 'Number' has no call signatures
```

1. 코드를 읽고 firstName이라는 변수를 이해합니다. 
2. 초깃값이 "Whitney"이라는 firstName이 string타입이라고 결론짓습니다.
3. firstName의 .length 멤버를 함수처럼 호출하는 코드를 확인합니다. 
4. string의 .length멤버는 함수가 아닌 숫자라는 오류를 표시합니다. 즉, 함수처럼 호출할 수 없습니다. 

2.1.2 오류 종류 

구문 오류 
구문 오류는 타입스크립트가 이해할 수 없는 잘못된 구문을 감지할 때 발생합니다. 이는 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단합니다. 

```ts
let let wat;
// error: ',' expected.
```
-> let let, wat; 

타입 오류
타입 오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생합니다. 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지는 않습니다. 하지만 코드가 실행되면 충돌하거나 예기치 않게 작동할 수 있음을 나타냅니다. 

```ts
console.blub("Nothing is worth more than laughter.");
// error: Property 'blub' does not exist on type 'Console'. 
```

2.2 할당 가능성
타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정합니다. 
변수에 새로운 값이 할당되면, 새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인합니다. 

```ts
let firstName = "Carole";
firstName = "Joen";
firstName = true;
// error: Type 'boolean' is not assignable to type 'string'.
```
2.3 타입 애너테이션 
초기 타입을 유추할 수 없는 변수 - 진화하는 any

```ts
let rocker; // 타입 any
rocker = "kim"; // string
rocker.toUpperCase(); // ok
rocker = 123; // number
rocker.toPrecision(1); // ok

rocker.toUpperCase();
// error : 'toUpperCase' does not exist on type 'number'.
```

타입 애너테이션은 변수 이름 뒤에 배치되며 콜론 (:)과 타입 이름을 차례대로 기재합니다. 
다음 타입 애너테이션은 rocker 변수가 string 타입임을 나타냅니다. 
다음 rocker를 number로 바꿈에 따라 toUpperCase()가 오류가 납니다. 

2.4 타입 형태
타입스크립트는 변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행합니다.
타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있습니다. 

```ts
let name = "kim";
name.length; // ok

name.push('!'); // error
```

2.4.1  모듈
자바스크립트는 비교적 최근까지 서로 다른 파일에 작성된 코드를 공유하는 방법과 관련된 사양을 제공하지 않았습니다. 

- 모듈 : export 또는 import가 있는 파일
- 스크립트 : 모듈이 아닌 모든 파일 

타입스크립트는 해당 파일을 전역 스코프로 간주하여 모든 스크립트 파일의 내용에 접근할 수 있습니다. 
export 또는 import 문으로 해결 가능합니다. 

3.1 유니언 타입 
이거 혹은 저거와 같은 타입을 유니언이라고 합니다. 
유니업 타입은 값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우 코드를 처리하는 훌륭한 개념입니다. 
타입스크립트는 가능한 값 또는 구성 요소 사이에 | 수직선 연산자를 사용해 유니언 타입임을 나타냅니다. 

3.1.1 유니언 타입 선언 

```ts
let thinker : string | null = null;

if  (Math.random() > 0.5) {
    thinker = "Susanne Langer"; // ok
}
```

thinker의 초깃값은 null이지만 잠재적으로 null 대신 string이 될 수 있음을 알려줍니다.
명시적으로 string | null 타입 애너테이션은 타입스크립트가 thinker의 값으로 string 타입의 값을 할당할 수 있음을 의미합니다. 

3.1.2 유니언 속성 
값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있습니다. 
유니언 외의 타입에 접근하려고 하면 타입 검사 오류가 발생합니다. 

3.2  내로잉
내로잉은 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것입니다.
타입을 좁히는데 사용할 수 있는 논리적 검사를 타입 가드라고 합니다. 

3.2.1 값 할당을 통한 내로잉 
변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힙니다. 

```ts
let admiral : number | string;

admiral = "Grace Hopper";

admiral.toUpperCase(); // ok

admiral.toFixed(); // error 
```

3.2.2 조건 검사를 통한 내로잉 
일반적으로 타입스크립트에서는 변수가 알려진 값과 같은 지 확인하는 if문을 통해 변수의 값을 좁히는 방법을 사용합니다. 

```ts
...
if(scientist === "Rosalind Franklin") {
    scientist.toUpperCase();
}
...
```

3.2.3 typeof 검사를 통한 내로잉
타입스크립트는 직접 값을 확인해 타입을 좁히기도 하지만, typeof 연산자를 사용할 수 있습니다. 

```ts
...
if(typeof researcher === "string") {
    researcher.toUpperCase(); // ok
}
...
```

3.3 리터럴 타입 
각 원시 타입은 해당 타입이 가질 수 있는 가능한 모든 리터럴 값의 전체 조합으로 생각할 수 있습니다. 
즉, 원시 타입은 해당 타입의 가능한 모든 리터럴 값의 집합입니다. 

3.4 엄격한 null 검사
리터럴로 좁혀진 유니언의 힘은 타입스크립트에서 업격한 null 검사라 부르는 타입 시스템 영역인 '잠재적으로 정의되지 않은 undefined 값'으로 작업할 때 특히 두드러집니다. 

`십억 달러의 실수' 
다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템을 가리키는 업계 용어입니다. 

3.4.2 참 검사를 통한 내로잉 
자바스크립트에서 참 또는 truthy는 &&연산자 또는 if 문 처럼 boolean 문맥에서 true로 간주됩니다. 
타입 스크립트에서는 잠재적인 값 중 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있습니다. 

```ts
let geneticist = Math.random() > 0.5
? "Barbara McClintock"
: undefined;
```

3.4.3 초깃갑이 없는 변수 
타입스크립트는 값이 할당될 때까지 변수가 undefined임을 이해할 만큼 충분히 영리합니다. 

3.5 타입 별칭
코드에서 볼 수 있는 유니언 타입 대부분은 두세 개의 구성 요소만 갖습니다. 
그러나 가끔 반복해서 입력하기 불편한 조금 긴 형태의 유니언 타입을 발견할 수 있습니다. 

타입스크립트에는 재사용하는 타입에 더 쉬운 이름을 할당하는 타입 별칭이 있습니다. 
타입 별칭은 type 새로운 이름 = 타입 형태를 갖춥니다. 
타입 별칭은 타입 시스템의 복사해서 붙여넣기 처럼 작동합니다. 
타입스크립트가 타입 별칭을 발견하면 해당 별칭이 참조하는 실제 타입을 입력한 것처럼 작동합니다. 

3.5.2 타입 별칭 결합
유니언 타입인 타입 별칭 내에 또 다른 유니언 탕비인 타입 별칭을 포함하고 있다면 다른 타입 별칭을 참조하는 것이 유용합니다. 

```ts
type Id = number | string;

type IdMaybe | undefined | null;
```
IdMaybe 타입은 undefined와 null, 그리고 Id 내의 타입을 포함한 유니언 타입입니다. 

4.1 객체 타입
타입스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는 타입 형태를 고려합니다. 
값의 속성에 접근하려면 value, 멤버 또는 value['멤버'] 구문을 사용합니다. 

4.1.1 객체 타입 선언
객체 타입은 객체 리터럴과 유사하게 보이지만 필드 값 대신 타입을 사용해 설명합니다. 
타입스크립트가 타입 할당 가능성에 대한 오류 메시지에 표시하는 것과 동일한 구문입니다. 

4.1.2 별칭 객체 타입
대부분의 타입스크립트 프로젝트는 객체 타입을 설명할 때 인터페이스 키워드를 사용하는 것을 선호합니다. 
참고로 별칭 객체 타입과 인터페이스는 거의 동일합니다. 

4.2 구조적 타이핑
타입스크립트의 타입 시스템은 구조적으로 타입화되어 있습니다. 
즉, 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 수 있습니다. 
매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 합니다. 

구조적 타이핑은 덕 타이핑과는 다릅니다.
덕 타이핑은 오리처럼 보이고 오리처럼 꽥꽥 거리면, 오리일 것이다.라는 문구가 유래했습니다. 

타입스크립트의 타입 검사기에서 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우입니다. 
덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말합니다. 

4.2.1 사용 검사 
객체 타입으로 애너테이션된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인합니다. 
할당하는 값에는 객체 타입의 필수 속성이 있어야 합니다. 

```ts
type FirstAndLastNames = {
    first : string;
    last : string;
};

const hasBoth : FirstAndLastNames = {
    first : "Sarojini",
    last : "Naidu",
};

const hasOnlyOne : FirstAndLastNames = {
    // error : Property 'last' is missing in type '{first : string;}'
    // but required in type "FirstAndLastNames".
    first : "Sappho"
}
```

4.2.2 초과 속성 검사 
변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있다면 타입스크립트에서 타입 오류가 발생합니다. 
따라서 변수를 객체 타입으로 선언하는 것은 타입 검사기가 해당 타입에 예상되는 필드만 있는지 확인하는 방법이기도 합니다. 

초과 속성 검사는 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어납니다.
기존 객체 리터럴을 제공하면 초과 속성 검사를 우회합니다. 

4.2.3 중첩된 객체 타입 
자바스크립트 객체는 다른 객체의 멤버로 중첩될 수 있으므로 타입스크립트의 객체 타입도 타입 시스템에서 중첩된 객체 타입을 나타낼 수 있어야 합니다. 
이를 구현하는 구문은 이전과 동일하지만 기본 이름 대신에 {...}객체 타입을 사용합니다. 

4.2.4 선택적 속성
타입의 속성 애너테이션에서 : 앞에 ?를 추가하면 선택적 속성임을 나타낼 수 있습니다. 

```ts
type Book = {
    author? : string;
    pages : number;
};
```

4.3 객체 타입 유니언
타입스크립트 코드에서는 속성이 조금 다룬, 하나 이상의 서로 다른 객체 타입이 될 수 있는 타입을 설명할 수 있어야 합니다. 또한 속성값을 기반으로 해당 객체 타입 간에 타입을 좁혀야 할 수도 있습니다. 

4.3.1 유추된 객체 타입 유니언
변수에 여러 객체 타입 중 하나가 될 수 있는 초깃갑이 주어지면 타입스크립트는 해당 타입을 객체 타입 유니언으로 유추합니다. 
유니언 타입은 가능한 각 객체 타입을 구성하고 있는 요소를 모두 가질 수 있습니다. 
객체 타입에 정의된 각각의 가능한 속성은 비록 초깃값이 없는 선택적 타입이지만 객체 타입의 구성 요소로 주어집니다. 

4.3.2 명시된 객체 타입 유니언
객체 타입의 조합을 명시하면 객체 타입을 더 명확히 정의할 수 있습니다. 
코드를 조금 더 작성해야 하지만 객체 타입을 더 많이 제어할 수 있다는 이점이 있습니다. 

잠재적으로 존재하지 않는 객쳍의 멤버에 대한 접근을 제한하면 코드의 안전을 지킬 수 있습니다.
값이 여러 타입 중 하나일 경우, 모든 타입에 존재하지 않는 속성이 객체에 존재할 거라 보장할 수 없습니다. 

리터럴 타입이나 원시 타입 모두, 혹은 둘 중 하나로 이루어진 유니언 타입에서 모든 타입에 존재하지 않은 속성에 접근하기 위해 타입을 좁혀야 하는 것처럼 객체 타입 유니언도 타입을 좁혀야 합니다. 

4.3.3 객체 타입 내로잉
타입 검사기가 유니언 타입 값에 특정 속성이 포함된 경우에만 코드 영역을 실행할 수 있음을 알게 되면, 값의 타입을 해당 속성을 포함하는 구성 요소로만 좁힙니다. 
즉, 코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용됩니다. 

```ts
if("pages" in poem) {
    poem.pages;  // ok : poem은 PoemWithPages로 좁혀짐
} else {
    poem.rhymes; // ok : poem은 PoemWithPages로 좁혀짐
}
```
명시적으로 입력된 poem 예제를 계속 살펴보면, poem의 pages가 타입스크립트의 타입 가드 역할을 해 poemWithRhymes임을 나타내는지 확인합니다. 

타입스크립트는 if와 같은 형식으로 참 여부를 확인하는 것은 허용하지 않습니다. 
존재하지 않는 객체의 속성을 접근하려고 시도하면 타입 가드처럼 작동하는 방식으로 사용되더라도 타입 오류로 간주됩니다. 

4.3.4 판별된 유니언
자바스크립트와 타입스크립트에서 유니언 타입으로 된 객체의 또 다른 인기 있는 형태는 객체의 속성이 객체의 형태를 나타내도록 하는 것입니다. 
이러한 타입 형태를 판별된 유니언이라 부르고, 객체의 타입을 가리키는 속성이 판별값입니다. 

판별된 유니언은 우아한 자바스크립트 패턴과 타입스크립트의 타입 내로잉을 아름답게 결합하므로 타입스크립트에서 필지가 가장 좋아하는 기능입니다. 

4.4 교차 타입
타입스크립트 유니언 타입은 둘 이상의 다른 타입 중 하나의 타입이 될 수 있음을 나타냅니다.
자바스크립트의 런타임 | 연산자가 & 연산자에 대응하는 역할을 하는 것처럼, 타입스크립트에서도 & 교차 타입을 사용해 여러 타입을 동시에 나타냅니다. 
교차 타입은 일반적으로 여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성합니다. 

교차 타입은 유니언 타입과 결합할 수 있으며, 이는 하나의 타입으로 판별된 유니언 타입을 설명하는데 유요합니다. 

4.4.1 교차 타입의 위험성

긴 할당 가능성 오류 
유니언 타입과 결합하는 것처럼 복잡한 교차 타입을 만들게 되면 할당 가능성 오류 메시지는 일기 어려워집니다.

never 
교차 타입은 잘못 사용학 ㅣ쉽고 불가능한 타입을 생성합니다. 
원시 타입의 값은 동시에 여러 타입이 될 수 없기 떄문에 교차 타입의 구성 요소로 함계 결합할 수 없습니다. 
두 개의 원시 타입을 함계 시도하면 never 키워드로 표시되는 never 타입이 됩니다. 